# Gestor de Tareas Inteligente (Java backend + Streamlit frontend)

Proyecto completo: backend en **Java (Spring Boot)** + frontend en **Streamlit (Python)**. Incluye: código fuente, `pom.xml`, `requirements.txt`, GitHub Actions para CI, y `README.md` con instrucciones para ejecutar y desplegar.

---

## Estructura del proyecto

```
gestor-tareas/
├─ backend/
│  ├─ pom.xml
│  └─ src/main/java/com/example/gestortareas/
│     ├─ GestorTareasApplication.java
│     ├─ controller/TaskController.java
│     ├─ model/Task.java
│     ├─ repository/TaskRepository.java
│     └─ service/TaskService.java
│  └─ src/main/resources/application.yml
├─ frontend/
│  ├─ app.py
│  └─ requirements.txt
├─ .github/workflows/ci.yml
└─ README.md
```

---

> En el documento están incluidos los contenidos de cada archivo. Copia cada archivo a tu repositorio siguiendo la estructura.

---

## README (resumen, en el repo verás el archivo completo)

Contenido detallado en el archivo `README.md` dentro del proyecto: instalación, cómo ejecutar backend y frontend, endpoints de la API, ejemplos de uso y despliegue. (Abre el documento para ver el `README.md` completo con pasos).

---

## Archivos - contenido (copia/pega a tu proyecto)

### backend/pom.xml

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>gestor-tareas</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <packaging>jar</packaging>
    <name>GestorTareas</name>
    <description>Gestor de tareas inteligente - Backend Spring Boot</description>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.1.4</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <properties>
        <java.version>17</java.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
```

---

### backend/src/main/java/com/example/gestortareas/GestorTareasApplication.java

```java
package com.example.gestortareas;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class GestorTareasApplication {
    public static void main(String[] args) {
        SpringApplication.run(GestorTareasApplication.class, args);
    }
}
```

---

### backend/src/main/java/com/example/gestortareas/model/Task.java

```java
package com.example.gestortareas.model;

import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "tasks")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Task {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String title;

    @Column(length = 2000)
    private String description;

    // Priority: 1 (highest) - 5 (lowest)
    private int priority;

    // Estimated duration in minutes
    private int estimatedMinutes;

    private boolean completed;

    private LocalDateTime dueDate;

    private LocalDateTime createdAt;

    private LocalDateTime updatedAt;

    @PrePersist
    public void prePersist() {
        createdAt = LocalDateTime.now();
        updatedAt = createdAt;
    }

    @PreUpdate
    public void preUpdate() {
        updatedAt = LocalDateTime.now();
    }
}
```

---

### backend/src/main/java/com/example/gestortareas/repository/TaskRepository.java

```java
package com.example.gestortareas.repository;

import com.example.gestortareas.model.Task;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface TaskRepository extends JpaRepository<Task, Long> {
    List<Task> findByCompleted(boolean completed);
    List<Task> findByTitleContainingIgnoreCase(String q);
}
```

---

### backend/src/main/java/com/example/gestortareas/service/TaskService.java

```java
package com.example.gestortareas.service;

import com.example.gestortareas.model.Task;
import com.example.gestortareas.repository.TaskRepository;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class TaskService {
    private final TaskRepository repo;

    public TaskService(TaskRepository repo) {
        this.repo = repo;
    }

    public Task create(Task t) {
        return repo.save(t);
    }

    public Optional<Task> get(Long id) { return repo.findById(id); }

    public List<Task> listAll() { return repo.findAll(); }

    public Task update(Long id, Task updated) {
        return repo.findById(id).map(t -> {
            t.setTitle(updated.getTitle());
            t.setDescription(updated.getDescription());
            t.setPriority(updated.getPriority());
            t.setEstimatedMinutes(updated.getEstimatedMinutes());
            t.setDueDate(updated.getDueDate());
            t.setCompleted(updated.isCompleted());
            return repo.save(t);
        }).orElseThrow(() -> new RuntimeException("Task not found"));
    }

    public void delete(Long id) { repo.deleteById(id); }

    public List<Task> search(String q) { return repo.findByTitleContainingIgnoreCase(q); }

    public List<Task> getPending() { return repo.findByCompleted(false); }

    /**
     * Simple intelligent prioritization:
     * Score each task by:
     *  - priority (lower number = more important)
     *  - due date closeness
     *  - estimated time (shorter tasks first to get quick wins)
     */
    public List<Task> suggestOrder() {
        List<Task> pending = getPending();
        LocalDateTime now = LocalDateTime.now();
        return pending.stream()
                .sorted(Comparator.comparingDouble(this::scoreTask))
                .collect(Collectors.toList());
    }

    private double scoreTask(Task t) {
        // lower is better
        double p = t.getPriority(); // 1..5
        double priorityFactor = p; // directly

        double dueFactor = 10.0; // default if no due date
        if (t.getDueDate() != null) {
            long hoursToDue = java.time.Duration.between(LocalDateTime.now(), t.getDueDate()).toHours();
            // if overdue, make it very high urgency
            if (hoursToDue <= 0) dueFactor = 0.1;
            else dueFactor = Math.max(0.1, (double) hoursToDue / 24.0); // days remaining scaled
        }

        double timeFactor = Math.max(1.0, t.getEstimatedMinutes() / 30.0); // prefer shorter tasks

        // Combine: weight prioritizing priority and due date
        double score = priorityFactor * 2.0 + dueFactor * 1.5 + timeFactor * 1.0;
        return score;
    }
}
```

---

### backend/src/main/java/com/example/gestortareas/controller/TaskController.java

```java
package com.example.gestortareas.controller;

import com.example.gestortareas.model.Task;
import com.example.gestortareas.service.TaskService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.net.URI;
import java.util.List;

@RestController
@RequestMapping("/api/tasks")
@CrossOrigin(origins = "*")
public class TaskController {
    private final TaskService service;

    public TaskController(TaskService service) {
        this.service = service;
    }

    @GetMapping
    public List<Task> list() { return service.listAll(); }

    @GetMapping("/pending")
    public List<Task> pending() { return service.getPending(); }

    @GetMapping("/suggest")
    public List<Task> suggest() { return service.suggestOrder(); }

    @GetMapping("/{id}")
    public ResponseEntity<Task> get(@PathVariable Long id) {
        return service.get(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @PostMapping
    public ResponseEntity<Task> create(@RequestBody Task t) {
        Task created = service.create(t);
        return ResponseEntity.created(URI.create("/api/tasks/" + created.getId())).body(created);
    }

    @PutMapping("/{id}")
    public ResponseEntity<Task> update(@PathVariable Long id, @RequestBody Task t) {
        try {
            Task updated = service.update(id, t);
            return ResponseEntity.ok(updated);
        } catch (RuntimeException ex) {
            return ResponseEntity.notFound().build();
        }
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> delete(@PathVariable Long id) {
        service.delete(id);
        return ResponseEntity.noContent().build();
    }

    @GetMapping("/search")
    public List<Task> search(@RequestParam String q) { return service.search(q); }
}
```

---

### backend/src/main/resources/application.yml

```yaml
server:
  port: 8080
spring:
  datasource:
    url: jdbc:h2:file:./data/gestor;DB_CLOSE_ON_EXIT=FALSE;AUTO_SERVER=TRUE
    driverClassName: org.h2.Driver
    username: sa
    password:
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: false
    properties:
      hibernate:
        format_sql: true

logging:
  level:
    org:
      springframework: INFO
```

---

## Frontend (Streamlit)

### frontend/requirements.txt

```
streamlit>=1.20.0
requests
pandas
python-dateutil
```

---

### frontend/app.py

```python
import streamlit as st
import requests
import pandas as pd
from datetime import datetime

API = st.sidebar.text_input("Backend API URL", value="http://localhost:8080/api/tasks")

st.title("Gestor de Tareas Inteligente")

menu = st.sidebar.selectbox("Menú", ["Ver tareas", "Crear tarea", "Sugerencias", "Buscar"])

if menu == "Ver tareas":
    r = requests.get(API)
    if r.status_code == 200:
        tasks = r.json()
        if not tasks:
            st.info("No hay tareas.")
        else:
            df = pd.DataFrame(tasks)
            # format dates
            for c in ["dueDate", "createdAt", "updatedAt"]:
                if c in df.columns:
                    df[c] = pd.to_datetime(df[c]).dt.tz_localize(None)
            st.dataframe(df)
            st.markdown("---")
            st.subheader("Acciones")
            col1, col2 = st.columns(2)
            with col1:
                tid = st.number_input("ID tarea a marcar como completada", min_value=1, step=1)
                if st.button("Marcar completada"):
                    res = requests.get(f"{API}/{int(tid)}")
                    if res.status_code == 200:
                        t = res.json()
                        t['completed'] = True
                        put = requests.put(f"{API}/{int(tid)}", json=t)
                        st.write(put.status_code, put.text)
            with col2:
                delid = st.number_input("ID tarea a eliminar", min_value=1, step=1, key='del')
                if st.button("Eliminar tarea"):
                    d = requests.delete(f"{API}/{int(delid)}")
                    st.write(d.status_code)

if menu == "Crear tarea":
    st.subheader("Nueva tarea")
    title = st.text_input("Título")
    desc = st.text_area("Descripción")
    prio = st.slider("Prioridad (1=alta,5=baja)", 1, 5, 3)
    est = st.number_input("Tiempo estimado (min)", min_value=5, max_value=1440, value=30)
    due = st.date_input("Fecha de vencimiento (opcional)")
    if st.button("Crear"):
        payload = {
            "title": title,
            "description": desc,
            "priority": prio,
            "estimatedMinutes": est,
            "completed": False,
            "dueDate": datetime.combine(due, datetime.min.time()).isoformat()
        }
        resp = requests.post(API, json=payload)
        st.write(resp.status_code)
        if resp.ok:
            st.success("Tarea creada")

if menu == "Sugerencias":
    st.subheader("Orden sugerido de tareas")
    r = requests.get(f"{API}/suggest")
    if r.status_code == 200:
        tasks = r.json()
        if not tasks:
            st.info("No hay tareas pendientes.")
        else:
            for i, t in enumerate(tasks, start=1):
                due = t.get('dueDate')
                st.markdown(f"**{i}. {t['title']}** — prioridad: {t['priority']} — estimado: {t['estimatedMinutes']} min — vencimiento: {due}")

if menu == "Buscar":
    q = st.text_input("Cadena a buscar en título")
    if st.button("Buscar"):
        r = requests.get(f"{API}/search", params={"q": q})
        if r.status_code == 200:
            res = r.json()
            df = pd.DataFrame(res)
            st.dataframe(df)
```

---

## GitHub Actions - CI (build backend + run unit tests)

### .github/workflows/ci.yml

```yaml
name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
      - name: Build with Maven
        working-directory: backend
        run: mvn -B clean verify
```

---

## Notas y mejoras opcionales

1. **Persistencia**: se usa H2 en modo archivo (`jdbc:h2:file:./data/gestor`) — fácil para pruebas. Para producción cambia a PostgreSQL/MySQL y actualiza `application.yml` y `pom.xml`.
2. **IA más avanzada**: el motor de priorización actual es heurístico. Puedes reemplazar `TaskService.suggestOrder` por un modelo ML (scikit-learn/Java ML) o un microservicio que use modelos entrenados.
3. **Autenticación**: añadir Spring Security + tokens JWT.
4. **Despliegue**: puedes dockerizar backend y frontend; Streamlit Cloud para frontend y Render/Heroku/Vercel para backend (o un único host con Docker Compose).
5. **WebSocket**: monitorización en tiempo real desde la UI.

---

## Siguientes pasos (qué hago por ti ahora)

* He incluido todo el código necesario para arrancar un backend Java (Spring Boot) y un frontend Streamlit minimalista que consume la API.
* Si quieres: puedo generar los archivos listos para descargar en un ZIP, o crear un commit inicial en un repo de GitHub (si me das permiso y acceso al repo). Dime qué prefieres.

---

**¡Listo!** Abre el documento y copia los archivos al repositorio, o dime si quieres que compacte todo y te entregue un ZIP descargable.
